ft_printf

.Variadic Functions and the Ellipsis (...):
	[https://medium.com/@turman1701/va-list-in-c-exploring-ft-printf-bb2a19fcd128]

	1. The arguments passed to the function using this mechanism are called “variable arguments(va)”;

	2. In C, the ellipsis (...) is used in function signatures to indicate that the function can accept an arbitrary number of arguments;

	va_list:
		It is a way for C functions to accept a variable number of arguments. It's like a special kind of list that holds all the extra arguments you pass to a function

	Key macros that come into play when using va_list. All these functions are in the <stdarg.h> library:
		a) va_start:
			Think of this as "starting the list". It initialises the list to point to the first variable argument.
		
		b) va_arg:
			This is how you get the next argument from the list.
		
		c) va_end:
			This "ends the list" and cleans things up.

		d) va_copy:
			This is for copying the list




----------------
.Example: Mini-printf that only supports %d (for integers) and %s (for strings):

#include <stdarg.h>
#include <stdio.h>

void mini_printf(const char *format, ...)
{
	va_list	args; // va_list variable to manage the variable arguments

	va_start(args, format); // init the va_list 'args' to start at the argument after 'format'

	while (*format) // looping through the string
	{
		if (*format =='%') // if a format specifier is encountered
		{
			format++; // increment format to the next char in string
			if (*format == 'd') // check if the char is 'd' (for integers)
			{
				printf("%d", va_arg(args, int)); // fecth the next arg as an integer and print it
			}
			else if (*format == 's') // check if the char is 's' (for strings)
			{
				printf("%s", va_arg(args, char *)); // fetch the next arg as string and print it
			} 
		}
		else
		{
			putchar(*format); // print regular characters
		}
		format++; // move to the next character
	}
	va_end(args); // cleanup the va_list arguments after processing
}

int	main(void)
{
	mini_printf("Hello %s, number is %d\n", "World", 42);
	return(0);
}
----------------


STDARG(3)

	SYNOPSIS
       #include <stdarg.h>

       void va_start(va_list ap, last);
       type va_arg(va_list ap, type);
       void va_end(va_list ap);
       void va_copy(va_list dest, va_list src);

	DESCRIPTION
       A function may be called with a varying number of arguments of varying types. The include file <stdarg.h> declares a type va_list and defines three macros for stepping through a list of arguments whose number and types are not known to the called function.

       The called function must declare an object of type va_list which is used by the macros
       va_start(), va_arg(), and va_end().


Diving more into each the arguments...

a)	void va_start(va_list ap, last):

	It is the starting point and init a 'va_list' to point to the first of the variable args.

	It uses 2 arguments:
		
		.'va_list' variable;
		.The last named arg before the variable args. ("i.e., the string???")
			OBS: 	It should not be declared as register variable, function or array type,
					because the address of this argument may be used in 'va_start()' macro.

	Ex:>> va_start(va_list args, format);

		This macro init 'args' for use by 'va_arg()' and 'va_end()'. IT MUST BE CALLED FIRST!!!


b)	type va_arg(va_list ap, type):

	It fetches (go and bring back) the next arg in the list. It moves the pointer forward by the size of the type specified.

	Each call to 'va_arg()' modifies the list, so that the next call returns the next arg.

	The arg 'type' is a type name specified. Successive invocations return the values of the remaining args.

	If there is no next arg, or if 'type' is not compatible with the type of actual next arg, random errors will occur.

	It uses 2 arguments:

		.The 'va_list' variable;
			OBS:	It is the same 'va_list' initialized by va_'start()';
		.The desired type of the next argument.

	Ex:>> va_arg(args, int));

		This will fetch the next arg as an integer.


c)	void va_end(va_list ap):

	Each invocation of 'va_start()' must be matched by a corresponding invocation of 'va_end()' in the same function. After the call va_end(ap) the variable ap is undefined. Multiple traversals of the list, each bracketed by 'va_start()' and 'va_end()' are possible. 'va_end()' may be a macro or a function.


d)	void va_copy(va_list dest, va_list src):

	On systems where arguments are passed in registers, it may be necessary for 'va_start()' to allocate memory, store the arguments there, and also an indication of which argument is next, so that 'va_arg()' can step through the list. Now 'va_end()' can free the allocated memory again. To accommodate this situation, C99 adds a macro va_copy(), so that the above assignment can be replaced by

           va_list aq;
           va_copy(aq, ap);
           ...
           va_end(aq);

    Each invocation of va_copy() must be matched by a corresponding invocation of va_end() in the same function.